<!-- {********************************************************} -->
<!-- {                     Delphi World ©                     } -->
<!-- {             Выпуск 2002 - 2003                         } -->
<!-- {             Автор проекта:   ___Nikolay                } -->
<!-- {             E-mail: DelphiWorld@mail.ru                } -->
<!-- {             http://delphiworld.narod.ru                } -->
<!-- {********************************************************} -->
<html>

<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="author" content="___Nikolay; mailto:delphiworld@mail.ru; http://delphiworld.narod.ru">
<meta Name="keywords" Content="delphi, дельфи, делфи, delfi, дэльфи, дэлфи, programming, программирование, soft, programs, программы, исходные коды, исходники, sources, сорцы, хакер, хак, hacker, hack, hacking, xakep, хакинг, Базы данных, Графика и Игры, Интернет и Сети, Компоненты и Классы, Мультимедиа, ОС и Железо, Программа и Интерфейс, Рабочий стол, Синтаксис, Технологии, Файловая система">
<meta Name="description" Content="Delphi World - это проект, являющийся сборником статей и малодокументированных возможностей  по программированию в среде Delphi">
<meta HTTP-EQUIV="Expires" content="Mon, 01 Jan 2000 00:00:00 GMT">
<title>Delphi World - Что такое порт (правила работы с портами)</title>
<link rel="stylesheet" href="css.css" type="text/css">
</head>

<body bgcolor="white" text="black" leftmargin=0 topmargin=0 rightmargin=0 bottommargin=0>
 
<table class=whitetable width="100%" cellspacing="0" cellpadding="0">
  <tr height=135>
    <td width="100%" background="images/bg_title.jpg"><img border="0" alt="Delphi World - это проект, являющийся сборником статей и малодокументированных возможностей  по программированию в среде Delphi. Здесь вы найдёте работы по следующим категориям: Базы данных, Графика и Игры, Интернет и Сети, Компоненты и Классы, Мультимедиа, ОС и Железо, Программа и Интерфейс, Рабочий стол, Синтаксис, Технологии, Файловая система и т.д." src="images/title.jpg" width="354" height="136"></td>
  </tr>
  <tr height=50>
    <td width="100%">
      <table width="90%" cellspacing="10" cellpadding="0" class="article">
        <tr>
          <td width="90%">

<!-- begin -->
<b>Что такое порт (правила работы с портами)</b>

<!--begin of Rambler's Top100 code -->
<a href="http://top100.rambler.ru/top100/">
<img src="http://counter.rambler.ru/top100.cnt?483925" alt="" width=1 height=1 border=0></a>
<!--end of Top100 code-->


<hr><br>

<table class=WhiteTable><tr><td></td><td width=50%>
Автор: <a href="mailto:kuzan@fsskomi.parma.ru" target="_blank">Дмитрий Кузан</a>
</td></tr></table><br>

<table class=anekdot><tr><td></td><td width=50%>
Сегодня мама грохнула о пол мой любимый компьютер. Горестно гляжу на разлетевшиеся детали:<br>
- Вот она материнская плата за сыновью любовь!
</td></tr></table><br>

<p>
Известно что в компьютере очень много собрано различных устройств ,
 возникает вопрос как операционная система общается с ними.
  Для этого и служит порт, то есть эта «дверь» через которую программа
   (операционная система) может управлять данным устройством
    (считывать данные, заносить их).Причем я разделяю порты на две категории
     (это чисто мое разделение) - порты общеизвестные (COM LPT)
      и порты внутренние ,служащие для связи с внутренними устройствами ЭВМ. 
<p>
<b>2.Некоторые правила для работы с портами </b>
<p>
Следует иметь в виду что при разработке программ имеющих дело
 работы с портами следует учитывать следующие факторы : 
<p>
а) Стараться использовать функции высокого уровня для доступа
 к портам (в частности WinAPI) и не прибегать к низкоуровневым операциям
  чтения/записи портов. Если вы все-таки решили писать низкоуровневое чтение
   то эти процедуры нужно выносить в отдельную DLL или VXD, по следующим причинам - известно,
    что операционная система Windows95/98 а особенно NT являются по своей
     сути многозадачными системами. То есть если ваша программа обращается
      конкретно к порту не через динамический вызов функции DLL или VXD 
      ( использования механизма DLL) а напрямую то это может сказаться
       на корректной работе системы или даже завалить ее. 
       И даже если в Windows95/98 такой подход вполне может работать
        то в Windows NT вследствие его архитектуры не разрешит
         непосредственное чтение/запись напрямую, а использование механизма
          DLL или VXD позволяет обойти эту проблему. 
<p>          
б)Если вы работаете с каким-то нестандартным портом ввода-вывода
 (например портом хранящим состояние кнопок пульта ДУ TVTunera
  то наверняка в комплекте поставки родного софта найдется
   DLL или VXD для управления этим устройством и отпадет нужда
    писать код, так я при работе с пультом ДУ TVTunerа
     использую стандартную DLL поставляемую в комплекте,
      это сразу решило вопросы связанные с управлением портами данного тюнера) 
<p>      
<b>Итак, отступление — немного практики</b>
<p>
Маленький пример для работы с портами
 (первый пример был уже опубликован в королевстве Дельфи
  и представлял собой пример работы с весами ПетрВес) 
</p>

<table><tr><td><br>
<PRE>
<B>function</B> PortInit : boolean; <FONT COLOR="#00007F"><I>//инициализация</FONT><FONT COLOR="#000000"></I>
<B>var</B> f: THandle;  
    ct: TCommTimeouts; 
    dcb: TDCB;
<B>begin</B>
  f := Windows.CreateFile(PChar('COM1'), GENERIC_READ <B>or</B>    
                              GENERIC_WRITE,
                              FILE_SHARE_READ <B>or</B> FILE_SHARE_WRITE,
                              <B>nil</B>, OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL, 0);
  <B>if</B> (f &lt;  0) <B>or</B> <B>not</B> Windows.SetupComm(f, 2048, 2048)<B>or</B> <B>not</B> 
      Windows.GetCommState(f, dcb) <B>then</B> exit; </FONT><FONT COLOR="#00007F"><I>//init error</FONT><FONT COLOR="#000000"></I>

  dcb.BaudRate := скоpость;
  dcb.StopBits := стоп-биты;
  dcb.Parity := четность;
  dcb.ByteSize := 8;
  <B>if</B> <B>not</B> Windows.SetCommState(f, dcb)
  <B>or</B> <B>not</B> Windows.GetCommTimeouts(f, ct) <B>then</B> exit; </FONT><FONT COLOR="#00007F"><I>//error</FONT><FONT COLOR="#000000"></I>
  ct.ReadTotalTimeoutConstant := 50;
  ct.ReadIntervalTimeout := 50;
  ct.ReadTotalTimeoutMultiplier := 1;
  ct.WriteTotalTimeoutMultiplier := 0;
  ct.WriteTotalTimeoutConstant := 10;
  <B>if</B> <B>not</B> Windows.SetCommTimeouts(f, ct)
  <B>or</B> <B>not</B> Windows.SetCommMask(f, EV_RING + EV_RXCHAR + EV_RXFLAG + EV_TXEMPTY)
<B>then</B> exit; </FONT><FONT COLOR="#00007F"><I>//error</FONT><FONT COLOR="#000000"></I>
  result := <B>true</B>;
<B>end</B>;

<B>function</B> DoneComm: boolean; </FONT><FONT COLOR="#00007F"><I>//закpыть поpт</FONT><FONT COLOR="#000000"></I>
<B>begin</B>
  result := Windows.CloseHandle(f);
<B>end</B>;

<B>function</B> PostComm(<B>var</B> Buf; size: word): integer; </FONT><FONT COLOR="#00007F"><I>//пеpедача в поpт</FONT><FONT COLOR="#000000"></I>
<B>var</B> p: pointer; i: integer;
<B>begin</B>
  p := @Buf;
  result := 0;
  <B>while</B> size &gt;  0 <B>do</B> <B>begin</B>
    <B>if</B> <B>not</B> WriteFile(f, p^, 1, i, <B>nil</B>) <B>then</B> exit;
    inc(result, i); inc(integer(p)); dec(size);
    Application.ProcessMessages;
    <B>end</B>;
<B>end</B>;

<B>function</B> ReadComm(<B>var</B> Buf; size: word): integer; </FONT><FONT COLOR="#00007F"><I>//пpием из поpта</FONT><FONT COLOR="#000000"></I>
<B>var</B> i: integer; ovr: TOverlapped;
<B>begin</B>
  fillChar(buf, size, 0);
  fillChar(ovr, sizeOf(ovr), 0); i := 0; result := -1;
  <B>if</B> <B>not</B> windows.ReadFile(f, buf, size, i, @ovr) <B>then</B> exit;
  result := i;
<B>end</B>;
</PRE>
      </font>
</td></tr></table><br>

<p>
Данный пример был взят мной из многочисленный FAQ посвященных в DELPHI в сети ФИДО 
Итак,для работы с портами COM и LPT нам понадобится знание функций Windows API.
<p>
Вот подробное описание функций, которые нам нужны (в эквиваленте C) для работы с портами.
(извините за возможный местами неточный перевод ,если что поправьте меня если что не так перевел) 
<p>
<b>CreateFile</b>
</p>

<table><tr><td><br>
<PRE>
HANDLE CreateFile(
    LPCTSTR lpFileName,&nbsp;   <FONT COLOR="#00007F"><I>// указатель на строку PCHAR с именем файла</FONT><FONT COLOR="#000000"></I>
    DWORD dwDesiredAccess, </FONT><FONT COLOR="#00007F"><I>// режим доступа</FONT><FONT COLOR="#000000"></I>
    DWORD dwShareMode,&nbsp;   </FONT><FONT COLOR="#00007F"><I>// share mode</FONT><FONT COLOR="#000000"></I>
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,&nbsp;</FONT><FONT COLOR="#00007F"><I>// указатель на атрибуты</FONT><FONT COLOR="#000000"></I>
    DWORD dwCreationDistribution,          </FONT><FONT COLOR="#00007F"><I>// how to create</FONT><FONT COLOR="#000000"></I>
    DWORD dwFlagsAndAttributes,&nbsp;      </FONT><FONT COLOR="#00007F"><I>// атрибуты файла</FONT><FONT COLOR="#000000"></I>
    HANDLE hTemplateFile &nbsp; </FONT><FONT COLOR="#00007F"><I>// хендл на temp файл</FONT><FONT COLOR="#000000"></I>
   );

</FONT><FONT COLOR="#00007F"><I>// Пример кода на Дельфи</FONT><FONT COLOR="#000000"></I>
</FONT><FONT COLOR="#00007F"><I>// &lt; вырезано&gt;</FONT><FONT COLOR="#000000"></I>

CommPort := 'COM2';               
hCommFile := CreateFile(Pchar(CommPort),                                      
                        GENERIC_WRITE, 0, <B>nil</B>,                                              
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 
                        0);
</FONT><FONT COLOR="#00007F"><I>// &lt; вырезано&gt;</FONT><FONT COLOR="#000000"></I>
</PRE>
      </font>
</td></tr></table><br>

<p>
Параметры 
<p>
LpFileName - Указатель на строку с нулевым символом в конце (PCHAR) ,
 которая определяет название создаваемого объекта (файл,
  канал, почтовый слот, ресурс связи (в данном случае порты),
   дисковое устройство, приставка, или каталог) 
<p>
DwDesiredAccess - Указывает тип доступа к объекту ,принимает значение 
<p>
GENERIC_READ - для чтения <br>
GENERIC_WRITE - для записи (смешивание с GENERIC_READ
 операцией GENERIC_READ and GENERIC_WRITE предостовляет полный доступ ) 
<p>
dwShareMode - 
Набор разрядных флагов, которые определяют как объект может быть разделен по доступу к нему.
 Если dwShareMode - 0, объект не может быть разделен.
  Последовательные операции открытия объекта будут терпеть неудачу,
   пока маркер(дескриптор) открытого объекта не будет закрыт.
    Фактически предоставляется монопольный доступ. 
<p>
Чтобы разделять объект(цель), используйте комбинацию одних или большее количество следующих значений: 
<p>
FILE_SHARE_DELETE (Только для Windows NT) <br>
FILE_SHARE_READ <br>
FILE_SHARE_WRITE 
<p>
LpSecurityAttributes - Указатель на структуру SECURITY_ATTRIBUTES, которая определяет
 может ли возвращенный дескриптор быть унаследован дочерними процессами.
  Если lpSecurityAttributes НУЛЕВОЙ, маркер не может быть унаследован.
   Используется только в windows NT. 
<p>
dwCreationDistribution - 
Определяет поведение функции если объект уже существует и
 как он будет открыт в этом случае Принимает одно из следующих значений : 
<p>
<blockquote>
CREATE_NEW  - Создает новый объект (файл) Выдает ошибку если указанный объект (файл) уже существует. 
<p>
CREATE_ALWAYS  - Создает новый объект (файл) Функция перезаписывает существующий объект (файл) 
<p>
OPEN_EXISTING - Открывает объект (файл) Выдает ошибку если указанный объект (файл) не существует.(Для более детального смотрите SDK) 
<p>
OPEN_ALWAYS  - Открывает объект (файл), если он существует. Если объект (файл) не существует,
 функция создает его, как будто dwCreationDistribution были CREATE_NEW. 
<p>
TRUNCATE_EXISTING  - Открывает объект (файл). После этого объект (файл) будет 
усечен до нулевого размера.Выдает ошибку если указанный объект (файл) не существует. 
</blockquote>
<p>
DwFlagsAndAttributes - Атрибуты объекта (файла) , атрибуты могут комбинироваться 
</p>

<ul type=square>
  <li>FILE_ATTRIBUTE_ARCHIVE 
  <li>FILE_ATTRIBUTE_COMPRESSED 
  <li>FILE_ATTRIBUTE_HIDDEN 
  <li>FILE_ATTRIBUTE_NORMAL 
  <li>FILE_ATTRIBUTE_OFFLINE 
  <li>FILE_ATTRIBUTE_READONLY 
  <li>FILE_ATTRIBUTE_SYSTEM 
  <li>FILE_ATTRIBUTE_TEMPORARY 
</ul>

<p>
HTemplateFile - Определяет дескриптор с GENERIC_READ доступом к временному объекту(файлу). 
Временный объект(файл)поставляет атрибуты файла и расширенные атрибуты
 для создаваемого объекта (файла) 
 ИСПОЛЬЗУЕТСЯ ТОЛЬКО В WINDOWS NT Windows 95: Это значение должно быть установлено в Nil. 
Возвращаемые значения
<p>
Если функция преуспевает, возвращаемое значение - открытый дескриптор
 к указанному объекту(файлу). Если файл не существует - 0. 
Если произошли функциональные сбои, возвращаемое значение - INVALID_HANDLE_VALUE.
 Чтобы получить расширенные данные об ошибках, вызовите GetLastError. 
<p>
<b>Обратите внимание!</b>
<p>
Для портов, dwCreationDistribution параметр должен быть OPEN_EXISTING,
 и hTemplate должен быть Nil. Доступ для чтения-записи должен быть определен явно. 
<p>
<b>SECURITY_ATTRIBUTES</b>
<p>
Структура содержит описание защиты для объекта и определяет,
может ли дескриптор быть унаследован дочерними процессами. 
</p>

<table><tr><td><br>
<pre>
<b>typedef struct</b> _SECURITY_ATTRIBUTES
{   DWORD  nLength;
    LPVOID lpSecurityDescriptor; 
    BOOL   bInheritHandle; 
} SECURITY_ATTRIBUTES;
</pre>
</td></tr></table><br>

<p>
Параметры
<p>
NLength - Определяет размер, в байтах, этой структуры.
 Набор это значение к размеру структуры SECURITY_ATTRIBUTES В Windows NT
  функции которые используют структуру SECURITY_ATTRIBUTES, не 
<p>  
LpSecurityDescriptor - Дескриптор указывающий на описатель защиты для объекта,
 Если дескриптор ПУСТОЙ объект может быть назначен в наследование дочерними процессами. 
<p> 
BInheritHandle - Определяет, унаследован ли возвращенный дескриптор, когда новый дескриптор, создан.
 Если это значение принимает ИСТИНУ новый дескриптор наследует от головного. 
<p> 
Замечания
<p>
Указатель на структуру SECURITY_ATTRIBUTES используется 
как параметр в большинстве функций работы с окнами в Win32 API. 
<p>
<b>Структура DCB</b>
<p>
Структура DCB определяет установку управления для последовательного порта ввода-вывода
 (нам она понадобится для разбора примера с программой управления весами ПетрВес) 
<p>
Примечание : В местах где нельзя дать точный перевод
 будет дано определение на английском из MSDK и приблизительный его перевод 
Описание в эквиваленте C
</p>

<table><tr><td><br>
<pre>
typedef struct _DCB { // dcb  
    DWORD DCBlength;           // Размер DCB
    DWORD BaudRate;            // Скорость пересылки данных в бодах; 
                               // текущая скорость в бодах 
    DWORD fBinary: 1;          // binary mode, no EOF check 
                               // двоичный режим , не проверять конец 
                               // данных (по умолчанию значение = 1)
    DWORD fParity: 1;          // Включить проверку четность (по умолчанию
                               // значение = 1)
    DWORD fOutxCtsFlow:1;      // CTS управление потоком выхода 
    DWORD fOutxDsrFlow:1;      // DSR управление потоком выхода 
    DWORD fDtrControl:2;       // DTR Тип управления потоком скорости 
                               // передачи данных
    DWORD fDsrSensitivity:1;   // DSR sensitivity (чувствительность)
    DWORD fTXContinueOnXoff:1; // XOFF continues Tx (стоп-сигнал 
                               // продалжает выполнение)
    DWORD fOutX: 1;            // XON/XOFF out flow control (СТАРТ-  
                               // СИГНАЛ / СТОП-СИГНАЛ для управления 
                               // выходящим потоком (по умолчанию
                               // значение = 1)
    DWORD fInX: 1;             // XON/XOFF in flow control (СТАРТ-
                               // СИГНАЛ / СТОП-СИГНАЛ для управления 
                               // входящим потоком (по умолчанию
                               // значение = 1)
    DWORD fErrorChar: 1;       // enable error replacement (включить 
                               // проверку погрешностей по умолчанию=1)
    DWORD fNull: 1;            // enable null stripping (отвергать
                               // пустой поток данных (по умолчанию=1))
    DWORD fRtsControl:2;       // RTS управление потоком данных
    DWORD fAbortOnError:1;     // abort reads/writes on error  
                               // (проверять операции чтения/записи 
                               // по умолчанию=1)
    DWORD fDummy2:17;          // reserved ЗАРЕЗЕРВИРОВАНО 
    WORD wReserved;            // not currently used НЕ ДЛЯ 
                               // ИСПОЛЬЗОВАНИЯ 
    WORD XonLim;               // transmit XON threshold (порог 
                               // чувствительности старт-сигнала)
    WORD XoffLim;              // transmit XOFF threshold (порог
                               // чувствительности стоп-сигнала)
    BYTE ByteSize;             // Бит в байте  (обычно 8)
    BYTE Parity;               // 0-4=no,odd,even,mark,space 
                               // (четность байта)
    BYTE StopBits;             // 0,1,2 = 1, 1.5, 2 (стоповые биты)
    char XonChar;              // Tx and Rx XON character (вид
                               // старт сигнал в потоке)
    char XoffChar;             // Tx and Rx XOFF character (вид
                               // стоп сигнал в потоке)
    char ErrorChar;            // error replacement character (какой     
                               // сигнал погрешности,его вид)
    char EofChar;              // end of input character (сигнал 
                               // окончания потока)
    char EvtChar;              // received event character  РЕЗЕРВ
    WORD wReserved1;           // reserved; do not use НЕ ДЛЯ 
                               // ИСПОЛЬЗОВАНИЯ
} DCB; 
</pre>
</td></tr></table><br>

<p>
Пример:
</p>

<table><tr><td><br>
<PRE>
<B>with</B> Mode <B>do</B>
  <B>Begin</B>
    BaudRate := 9600;
    ByteSize := 8;
    Parity := NOPARITY;
    StopBits := ONESTOPBIT; <FONT COLOR="#00007F"><I>// одиночный стоп-бит</FONT><FONT COLOR="#000000"></I>
    Flags := EV_RXCHAR + EV_EVENT2;
  <B>End</B>;
</PRE>
      </font>
</td></tr></table><br>

<p>
Параметры :
<p>
DCBlength - Размер DCB структуры. 
<p>
BaudRate - Определяет скорость в бодах, в которых порт оперирует.
 Этот параметр может принимать фактическое значение скорости в бодах,
  или один из следующих стандартных индексов скорости в бодах: 
<p>

<pre>  
CBR_110 	CBR_19200
CBR_300 	CBR_38400
CBR_600 	CBR_56000
CBR_1200	CBR_57600
CBR_2400	CBR_115200
CBR_4800	CBR_128000
CBR_9600	CBR_256000
CBR_14400	
</pre>

<p>
fBinary - Определяет, допускается ли двоичный (бинарный) способ передачи данных.
 Win32 API не поддерживает недвоичные (небинарные) 
 способы передачи данных в потоке порта, так что этот параметр
  должен быть всегда ИСТИНЕН. 
  Попытка использовать ЛОЖЬ в этом параметре не будет работать. 
<p>  
Примечание :
<p>
Под Windows 3.1 небинарный способ передачи допускается,
но для работы данного способа необходимо заполнит параметр
 EofChar который будет восприниматься конец данных. 
<p> 
fParity - Определяет, допускается ли проверка четности.
 Если этот параметр ИСТИНЕН, проверка четности допускается 
<p> 
fOutxCtsFlow - CTS (clear-to-send) управление потоком выхода 
<p>
fOutxDsrFlow - DSR (data-set-ready) управление потоком выхода 
<p>
fDtrControl - DTR (data-terminal-ready) управление потоком выхода
<p>
Принимает следующие значения : 
<p>
DTR_CONTROL_DISABLE - Отключает линию передачи дынных <br>
DTR_CONTROL_ENABLE - Включает линию передачи дынных <br>
DTR_CONTROL_HANDSHAKE - Enables DTR handshaking. If handshaking is enabled,
 it is an error for the application to adjust the line by using the EscapeCommFunction function. 
<p>
Допускает подтверждению связи передачи данных
 Если подтверждение связи допускается, это - погрешность для того чтобы регулировать(корректировать)
  линию связи, используя функцию EscapeCommFunction. 
<p>  
fDsrSensitivity - Specifies whether the communications driver is sensitive to the state of the DSR signal.
 If this member is TRUE, the driver ignores any bytes received, unless the DSR modem input line is high. 
Определяет возможна ли по порту двухсторонняя передача в ту и в другую сторону сигнала. 
<p>
fTXContinueOnXoff - Определяет, останавливается ли передача потока ,
 когда входной буфер становится полный, и драйвер передает сигнал XoffChar. 
 Если этот параметр ИСТИНЕН, передача продолжается после того, 
 как входной буфер становится в пределах XoffLim байтов, и драйвер передает
  сигнал XoffChar, чтобы прекратить прием байтов из потока . 
  Если этот параметр ЛОЖНЫЙ, передача не продолжается до тех пор ,
   пока входной буфер не в пределах XonLim байтов,
    и пока не получен сигнал XonChar, для возобновления приема . 
<p>    
fOutX - Определяет, используется ли управление потоком СТАРТ-СИГНАЛА / СТОП-СИГНАЛА
 в течение передачи потока порту. Если этот параметр ИСТИНЕН, передача останавливается,
  когда получен сигнал XoffChar и начинается снова, когда получен сигнал XonChar. 
<p>  
fInX - Specifies whether XON/XOFF flow control is used during reception. If this member is TRUE,
 the XoffChar character is sent when the input buffer comes 
 within XoffLim bytes of being full, and the XonChar character is sent 
 when the input buffer comes within XonLim bytes of being empty.
  Определяет, используется ли управление потоком СТАРТ-СИГНАЛА / СТОП-СИГНАЛА
   в течение приема потока портом. Если этот параметр ИСТИНЕН,сигнал XoffChar посылается ,
    когда входной буфер находится в пределах XoffLim байтов, а сигнал XonChar посылается 
    тогда когда входной буфер находится в пределах XonLim байтов или является пустым 
<p>    
fErrorChar - Определяет, заменены ли байты, полученные с ошибками четности особенностью,
 указанной параметром ErrorChar Если этот параметр ИСТИНЕН, и fParity ИСТИНЕН, замена происходит. 
<p> 
fNull - Определяет, отвергнуты ли нулевые(пустые) байты. Если этот параметр ИСТИНЕН,
 нулевые(пустые) байты, будут отвергнуты при получении их. 
<p> 
fRtsControl - RTS управление потоком "  запрос пересылки " .
 Если это значение нулевое, то по умолчанию устанавливается RTS_CONTROL_HANDSHAKE.
  Принимает одно из следующих значений: 
<p>  
RTS_CONTROL_DISABLE - Отключает строку RTS, когда устройство открыто <br>
RTS_CONTROL_ENABLE - Включает строку RTS <br>
RTS_CONTROL_HANDSHAKE - Enables RTS handshaking. The driver raises the RTS line
 when the " type-ahead"  (input)
  buffer is less than one-half full and lowers 
  the RTS line when the buffer is more than three-quarters full.
   If handshaking is enabled, it is an error for the application
    to adjust the line by using the EscapeCommFunction function. 
<p>    
Допускает RTS подтверждение связи. Драйвер управляет потоком пересылки.
RTS выравнивается , когда входной буфер - меньше чем половина полного и
 понижается, когда буфер - больше 2/3 полного .Если подтверждение связи
  допускается, это используется для регулирования передачи данных
   EscapeCommFunction. 
<p>   
RTS_CONTROL_TOGGLE - Specifies that the RTS line will be high if bytes are available for transmission. 
After all buffered bytes have been sent, the RTS line will be low.
 Определяет, что буфер будет высокий при подготовке данных для передачи.
  После того, как все байты отосланы, буфер RTS будет низок. 
<p>  
FAbortOnError - Определяет, закончена ли операции чтения/записи, если происходит погрешность. 
Если этот параметр ИСТИНЕН, драйвер закрывает все операции
 чтения/записи с состоянием погрешности при возникновении оной. 
<p> 
Драйвер не будет принимать никакие дальнейшие действия,
 пока не дождется подтверждения погрешности в передоваемых 
 (принимаемых) данных, вызывая функцию ClearCommError. 
<p> 
fDummy2 - ЗАРЕЗЕРВИРОВАНО Microsoft <br>
wReserved - ЗАРЕЗЕРВИРОВАНО Microsoft 
<p>
XonLim - Определяет минимальное число байтов, находящихся во в
<p>
XoffLim - Определяет максимальное число байтов, находящихся во входном буфере прежде,
 чем будет генерирована подача СТОП-СИГНАЛА. Максимальное число байтов,
  позволенных во входном буфере вычитается из размеров, в байтах, самого входного буфера. 
<p>  
ByteSize - Определяет число битов в байтах, переданных и полученных. 
<p>
Parity - Определяет схему четности, которую нужно использовать.
 Этот параметр может быть одним из следующих значений: 
<p> 
EVENPARITY	<br>
MARKPARITY	<br>
NOPARITY	<br>
ODDPARITY	
<p>
StopBits - Определяет число стоповых битов, которые нужно использовать. 
Этот параметр может быть одним из следующих значений: 
<p>
ONESTOPBIT	1 stop bit<br>
ONE5STOPBITS	1.5 stop bits<br>
TWOSTOPBITS	2 stop bits
<p>
XonChar - Определяет значение СТАРТ-СИГНАЛА для передачи и приема. <br>
XoffChar - Определяет значение СТОП-СИГНАЛА для передачи и приема. <br>
ErrorChar - Определяет значение СИГНАЛА ОШИБКИ (генерируемого при ошибке четности) для передачи и приема. <br>
EofChar - Определяет значение сигнала конца данных. <br>
EvtChar - Определяет значение сигнала события. <br>
wReserved1 - ЗАРЕЗЕРВИРОВАНО Microsoft 
<p>
Дополнение :
<p>
Когда структура DCB использует «ручной» выбор конфигурации ,
 следующие ограничения используются для ByteSize и StopBits параметров : 
Число информационных разрядов должно быть от 5 до 8 битов. 
Использование 5 информационных разрядов с 2 стоповыми битами -
 недопустимая комбинация, как - 6, 7, или 8 информационных разрядов с 1.5 стоповыми битами. 
</p>

<!-- end -->
          </td>
        </tr>
      </table>
    </td>
  </tr>
  <tr height=15>
    <td width="100%" background="images/bottom_line.jpg"></td>
  </tr>
  <tr>    
    <td width="100%" align=center>Проект <a href="mailto:delphiworld@mail.ru" title="Отправить статью или интересную работу">Delphi World</a> © Выпуск 2002
      - 2003 <br>Автор проекта: <a href="mailto:delphiworld@mail.ru" title="Написать письмо">___Nikolay</a>
<br><br>

<!--begin of Top100 logo-->
<a href="http://top100.rambler.ru/top100/">
<img src="http://top100-images.rambler.ru/top100/banner-88x31-rambler-blue3.gif" alt="Rambler's Top100" width=88 height=31 border=0></a>
<!--end of Top100 logo -->

<!--Rating@Mail.ru COUNTER--><script language="JavaScript"><!--
d=document;a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3"><!--
js=13//--></script><script language="JavaScript"><!--
d.write('<a href="http://top.mail.ru/jump?from=574272"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=574272;t=230;js='+js+a+';rand='+Math.random()+
'" alt="Рейтинг@Mail.ru"'+' border=0 height=31 width=88></a>')
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a
target=_top href="http://top.mail.ru/jump?from=574272"><img
src="http://top.list.ru/counter?js=na;id=574272;t=230"
border=0 height=31 width=88
alt="Рейтинг@Mail.ru"></a></noscript><script language="JavaScript"><!--
if(js>11)d.write('--'+'>')//--></script><!--/COUNTER-->

<br>

<font size=1 color=white>
<a target="_top" href="http://w.extreme-dm.com/?login=delphiwo">
<img STYLE="filter:Alpha(Opacity=0, FinishOpacity=0, Style=3, StartX=X, StartY=Y, FinishX=X, FinishY=Y)"
 src="http://w1.extreme-dm.com/i.gif" height=38
border=0 width=41 alt=""></a><script language="javascript1.2"><!--
EXs=screen;EXw=EXs.width;navigator.appName!="Netscape"?
EXb=EXs.colorDepth:EXb=EXs.pixelDepth;//-->
</script><script language="javascript"><!--
EXd=document;EXw?"":EXw="na";EXb?"":EXb="na";
EXd.write("<img src=\"http://w0.extreme-dm.com",
"/0.gif?tag=delphiwo&j=y&srw="+EXw+"&srb="+EXb+"&",
"l="+escape(EXd.referrer)+"\" height=1 width=1>");//-->
</script><noscript><img height=1 width=1 alt=""
src="http://w0.extreme-dm.com/0.gif?tag=delphiwo&j=n"></noscript>
</font>
</td>
  </tr>
</table>
<br> 
 
</body>
</html>
<!-- ><!-- "><!-- '><!-- --></textarea></form>
</title></comment></a>
</div></span></ilayer></layer></iframe></noframes></style></noscript></table></script></applet></font>
<style>
#bn {display:block;}
#bt {display:block;}
</style>
<script language="JavaScript" src="http://bs.yandex.ru/show/163?ncid=0%0A61%0A139"></script>
<!-- mailto:spm111@yandex.ru -->